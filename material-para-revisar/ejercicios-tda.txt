- tubería
  largo y dirección
  vaEnDireccion(tub, dir), devuelve booleano
  esMediana(tub), true si su largo está entre 3 y 8
  sonCompatibles(tub1, tub2): true si van en la misma dirección
  conectadas(tub1, tub2): la tubería que resulta de conectar tub1 y tub2 si son compatibles (dirección de tub1, largo la suma), tub1 en caso contrario.


- sorteo con dos números premiados, y el multiplicador (o sea, cuánto paga por cada peso apostado).
  Agregar apuesta con número e importe apostados.
  O sea, tenemos dos TDA: sorteo y apuesta.
  Posibles operaciones
  esNumeroGanador(sorteo, numero)
  esApuestaGanadora(sorteo, apuesta)
  importeAPagar(sorteo, apuesta): el importe de la apuesta por el mutiplicador si la apuesta es ganadora; 0 en caso contrario.
  duplicada(apuesta): devuelve una apuesta al mismo número con el doble del importe.
  esApuestaPermitida(apuesta): si el importe no supera 1000 pesos
  premiadosSonCercanos(sorteo): si los números premiados no están a más de 10 números de distancia. 


- rectángulo
  Acá se puede plantear un TDA puntoCartesiano y otro rectangulo.
  También se puede pensar en un segmento con los extremos.
  perimetro(rect) / area(rect) / verticeInferiorIzquierdo(rect) (el punto) / los otros tres vértices.
  opción: un enum Vertices y una sola operación vertice(rect,vertice)
  aLaDerecha(punto,cuanto): devuelve un nuevo punto.
  Idem en las otras tres direcciones, o bien un enum Direccion y una sola operación
  desplazado(punto,direccion,cuanto).
  movido(rect,direccion,cuanto)
  esCuadrado(rect)
  estirando(rect,direccion,cuanto) p.ej. 
  estirando(nuevoRectangulo(nuevoPunto(0,0),nuevoPunto(3,3)),Este,2) resulta en el rectángulo
    (0,0) - (5,3)


- operación con operandos y resultado.
  OJO este es más difícil, aparecen polimorfismo e idea de recursividad.
  polimorfismo sobre valor()
  Hace falta un "caso base": numero.
  P.ej. nuevaSuma(nuevaMult(numero(3),numero(4)), numero(6)).valor() debería dar 18.

